"use strict";
var axios_1 = require("axios");
var stream_1 = require("stream");
var exceptions_1 = require("./exceptions");
var fileType = require("file-type");
var pkg = require("../package.json");
function wrapError(err) {
    if (err.response) {
        throw new exceptions_1.HTTPError(err.message, err.response.status, err.response.statusText, err);
    }
    else if (err.code) {
        throw new exceptions_1.RequestError(err.message, err.code, err);
    }
    else if (err.config) {
        // unknown, but from axios
        throw new exceptions_1.ReadError(err);
    }
    // otherwise, just rethrow
    throw err;
}
var userAgent = pkg.name + "/" + pkg.version;
function stream(url, headers) {
    headers["User-Agent"] = userAgent;
    return axios_1["default"]
        .get(url, { headers: headers, responseType: "stream" })
        .then(function (res) { return res.data; });
}
exports.stream = stream;
function get(url, headers) {
    headers["User-Agent"] = userAgent;
    return axios_1["default"]
        .get(url, { headers: headers })
        .then(function (res) { return res.data; })
        .catch(wrapError);
}
exports.get = get;
function post(url, headers, data) {
    headers["Content-Type"] = "application/json";
    headers["User-Agent"] = userAgent;
    return axios_1["default"]
        .post(url, data, { headers: headers })
        .then(function (res) { return res.data; })
        .catch(wrapError);
}
exports.post = post;
function postBinary(url, headers, data, contentType) {
    var getBuffer;
    if (Buffer.isBuffer(data)) {
        getBuffer = Promise.resolve(data);
    }
    else {
        getBuffer = new Promise(function (resolve, reject) {
            if (data instanceof stream_1.Readable) {
                var buffers_1 = [];
                var size_1 = 0;
                data.on("data", function (chunk) {
                    buffers_1.push(chunk);
                    size_1 += chunk.length;
                });
                data.on("end", function () { return resolve(Buffer.concat(buffers_1, size_1)); });
                data.on("error", reject);
            }
            else {
                reject(new Error("invalid data type for postBinary"));
            }
        });
    }
    return getBuffer.then(function (data) {
        headers["Content-Type"] = contentType || fileType(data).mime;
        headers["Content-Length"] = data.length;
        headers["User-Agent"] = userAgent;
        return axios_1["default"]
            .post(url, data, { headers: headers })
            .then(function (res) { return res.data; })
            .catch(wrapError);
    });
}
exports.postBinary = postBinary;
function del(url, headers) {
    headers["User-Agent"] = userAgent;
    return axios_1["default"]
        .delete(url, { headers: headers })
        .then(function (res) { return res.data; })
        .catch(wrapError);
}
exports.del = del;
//# sourceMappingURL=http.js.map